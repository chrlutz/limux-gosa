<?php
//
// This code is part of GOsa (http://www.gosa-project.org)
//
// Copyright (C) 2014 Landeshauptstadt MÃ¼nchen
// Author: Matthias S. Benkmann
//
// This program is free software;
// you can redistribute it and/or modify it under the terms of the
// GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
//
// IMPORTANT: YOU NEED TO CONFIGURE YOUR /etc/ldap/ldap.conf PROPERLY,
// OR YOU WILL HAVE TO EDIT ldap2fai-pxelinuxcfg-common.php WITH YOUR
// LDAP CONFIGURATION.
// YOU ALSO NEED TO CREATE A CONFIG FILE /etc/gosa/pxelinux.conf (see below)
//
// This script constructs a configuration file for pxelinux
// (see http://www.syslinux.org/wiki/index.php/PXELINUX) 
// from the data found in LDAP as written by GOsa.
//
// This script accepts as argument a MAC address in one of the following
// forms:
//   * 01-xx-yy-zz-aa-bb-cc  (case-insensitive)
//   * xx:yy:zz:aa:bb:cc     (case-insensitive)
//   * either of the above forms followed by one or more file extensions
//     (e.g. ".txt" or ".tar.gz")
//
// The MAC address argument can be passed in the following ways:
//   * as the suffix of the request URI, preceded by "/", "?" or "=".
//   * as command line argument when executing the script directly
//   * in an environment variable "macaddress" (lower-case)
// The above locations will be checked in order and the first non-empty one
// will be used.
//
// The format of /etc/gosa/pxelinux.conf is demonstrated by the following
// example:
//--------------------------------------------------------------------
// default auto-generated
// label auto-generated
// 
// 
// # New system not yet in LDAP
// [dn ^$]
// faiclass=":default"
// faistate="install"
// 
// # No boot kernel set in LDAP
// [gotobootkernel ^$]
// gotobootkernel="default"
// 
// # No faistate attribute or faistate is "localboot"
// [faistate ^$|^localboot]
// localboot 0
// 
// [faistate ^install]
// # ${faios} is generated by pxelinux.php and is the part after ":" in ${faiclass}
// kernel ${faios}/${gotobootkernel}/vmlinuz
// initrd ${faios}/${gotobootkernel}/initrd.img
// append nfsroot=/nfsroot,nfs4,union FAI_ACTION=install FAI_FLAGS=syslogd,verbose,sshd,poweroff,skipusb ip=dhcp devfs=nomount root=/dev/nfs
// ipappend 2
// 
// # Fallback if none of the other faistate sections match.
// # The variable ${faierror} is generated by pxelinux.php. If a faistate is
// # known for the machine and it starts with "error:" then ${faierror} is
// # the base64 encoding of the rest following the "error:".
// # Otherwise ${faierror} is the base64 encoding of a generic message.
// [!faistate]
// append nfsroot=/nfsroot,nfs4,union FAI_ERROR=${faierror} FAI_ACTION=sysinfo FAI_FLAGS=syslogd,verbose,sshd,poweroff,skipusb ip=dhcp devfs=nomount root=/dev/nfs
// initrd default/default/initrd.img
// kernel default/default/vmlinuz
// ipappend 2
//
//--------------------------------------------------------------------------
// The config file consists of the following types of lines:
// * [attribute regex]
//   attribute is from the machine's LDAP object (or an object group).
//   Note that only a subset
//   of attributes are imported from LDAP. See $required = array(...) in the code.
//   regex is a PHP regular expression (see preg_match())
//   All lines following the [...] line up to the next [...] line will be
//   output only if the value of attribute matches regex (non-anchored).
//   An attribute not present on the object is considered to be "".
//
// * [!attribute]
//   Similar to [attribute regex] but matches only if no [attribute regex] matched
//   earlier in the file. It's essentially an "else" branch for attribute.
//
// * attribute="..."
//   Assigns "..." to the attribute. The actual LDAP object is NOT modified.
//   The assignment will affect the following lines. It is possible to
//   assign values to attributes not originally present on the LDAP object.
//
// * # comment
//   A line whose first non-whitespace character is "#" is ignored.
//
// * literal
//   All lines that don't fall into one of the above categories are
//   output directly and are supposed to be directives understood by
//   pxelinux.
//
// Variable substitutions:
// Occurrences of ${attribute} in all lines are replaced with the value of
// the respective attribute. Note that only a subset of attributes are
// imported from LDAP. The following substitutions are available:
// * LDAP attributes set on the machine's LDAP object
// * LDAP attributes set on object groups the machine is a member of
// * all attributes set via attribute="..." assignments in earlier lines.
// * ${faios}
//   The part after the last ":" in the attribute ${faiclass}, if present.
//   Otherwise "unknown".
// * ${faierror}
//   The base64-encoding of the part after the first ":" in ${faistate}, if present.
//   Otherwise a generic error.



/*
 * Close LDAP connection, log error and return 500 Internal Server Error.
 */
function ldapdie($ldap, $msg)
{
    //http_response_code(500);
    $protocol = (isset($_SERVER['SERVER_PROTOCOL']) ? $_SERVER['SERVER_PROTOCOL'] : 'HTTP/1.0');
    header("$protocol 500 Internal Server Error");

    if ($ldap) {
        $err = ldap_error($ldap);
        @ldap_close($ldap);
        if ($err != "Success")
            $msg = sprintf("%s: %s\n", $msg, $err);
    }
    die($msg."\n");
}

// This is called if LDAP access works but the object is not found.
function no_ldap_entry_for_machine($ldap)
{
    // No error. We send the default config for a client install.
}

$required = array("macaddress" => TRUE,
                  "faistate" => FALSE,
                  "faidebianmirror" => FALSE,
                  "gosaunittag" => FALSE,
                  "gotoldapserver" => FALSE,
                  "gotomode" => FALSE,
                  "gotontpserver" => FALSE,
                  "iphostnumber" => FALSE,
                  "cn" => TRUE,
                  "gotobootkernel" => FALSE,
                  "faiclass" => FALSE,
                  "gotokernelparameters" => FALSE);
require (dirname(__FILE__) . '/ldap2fai-pxelinuxcfg-common.php');


function set_auto_variables(&$machine) {
    $faios = "unknown";
    if (isset($machine['faiclass'][0])) {
      $i = strrpos($machine['faiclass'][0], ":");
      if ($i !== FALSE) {
        $faios = trim(substr($machine['faiclass'][0], $i+1));
      }
    }
    $machine['faios']["count"] = 1;
    $machine['faios'][0] = $faios;

    $faierror = "pxelinux:-1:crit:Unknown error or no error.";
    if (isset($machine['faistate'][0])) {
      $i = strpos($machine['faistate'][0], ":");
      if ($i !== FALSE) {
        $faierror = trim(substr($machine['faistate'][0], $i+1));
      }
    }
    $machine['faierror']["count"] = 1;
    $machine['faierror'][0] = base64_encode($faierror);
}

$machine_dn = "";
if (isset($machine['dn'])) { $machine_dn = $machine['dn']; }
$machine['dn'] = array('count' => 1, 0 => $machine_dn );

$conf = file("/etc/gosa/pxelinux.conf", FILE_IGNORE_NEW_LINES);
if ($conf === FALSE) {
    $conf = array();
}

header('Content-type: text/plain');

$have_match = array();
$skip = FALSE;
for ($i = 0; $i < count($conf); $i ++) {
    $line = trim($conf[$i]);
    if (strpos($line, "#") !== 0) {
      $matches = array();
      
      if (preg_match('/^\[([a-z]+)\s+(.*)\]$/', $line, $matches)) {
        $varname = $matches[1];
        $regex = $matches[2];
        $value = "";
        set_auto_variables($machine);
        if (isset($machine[$varname][0])) {
          $value = $machine[$varname][0];
        }
        if (preg_match("/$regex/", $value)) {
          $skip = FALSE;
          $have_match[$varname] = TRUE;
        } else {
          $skip = TRUE;
        }
        continue;
      }
      
      if (preg_match('/^\[!([a-z]+)]$/', $line, $matches)) {
        $varname = $matches[1];
        if (isset($have_match[$varname])) {
          $skip = TRUE;
        } else {
          $skip = FALSE;
        }
      }
      
      if ($skip === TRUE) { continue; }
      
      if (preg_match_all('/\$\{[a-z]+\}/', $line, $matches, PREG_OFFSET_CAPTURE)) {
        foreach (array_reverse($matches[0]) as $match) {
          $ofs = $match[1];
          $len = strlen($match[0]);
          $varname = substr($match[0], 2, $len - 3);
          $value = "";
          set_auto_variables($machine);
          if (isset($machine[$varname][0])) {
            $value = $machine[$varname][0];
          }
          $line = substr_replace($line, $value, $ofs, $len);
        }
      }
      
      if (preg_match('/^([a-z]+)\s*=\s*"(.*)"$/', $line, $matches)) {
        $varname = $matches[1];
        $value = $matches[2];
        $machine[$varname] = array('count' => 1, 0 => $value );
        continue;
      }
      
      print($line);
      print("\n");
    }
}

?>
